---                                                                                                                                                                          
status: published
title: Querying a Music Theory Database
tags:
  - perl
  - prolog
  - MIDI
  - music
  - analysis
  - software
---

For a long time, I have wondered how to easily know what chords have a diatonic function in two different keys (modes). This is known as a ["common"](https://en.wikipedia.org/wiki/Common_chord_(music)) or "pivot" chord.

---

Naturally, being a software engineer, I wrote a program to answer this for me! =)

For our purposes, the essential question is this: "Can a chord in one key function in a second?" Any parts of this open-ended question may be unbound, thereby resulting in all possible truths.

How are "all possible truths" determined? Well the short answer is "With Prolog!" What does "unbound" mean here? Well, that's another Prolog concept, and I will explain briefly: Basically in Prolog there are only atoms and facts, rules and variables. The atoms are literals. Facts are relations between atoms. Rules are compound statements about facts with variables standing for atoms that make the rule true. Truth or falsehood is the essential result of any Prolog query. "Bound" variables are those associated with a particular atom or series of atoms. "Unbound" variables are not literally associated, but rather stand in place of atoms that would make the query true. (Whew! Confused yet? Haha.)

So in Prolog, I was able to ask questions like, "In what mode(s) can a Gmaj chord function as a subdominant pivot chord?" Or, "In what mode(s) can a Gmaj chord function as a pivot chord with any function?" The first question has six answers. The second has more results. A query with no atoms (literals) and **all** variables can return an astronomical number of alternate true results.

This was a breakthrough for me. I could finally know what pivot chords function in what modes. But this was still a **manual** thing. That is, I had to type in my full question and interact with the Prolog interpreter. This was not going to scale and would not suffice for automation.

Enter Perl!

With Perl and the excellent [Music::Scales](https://metacpan.org/pod/Music::Scales) module, I was able to generate every single fact about every single note of every single mode, on the fly, and save this in a Prolog database.

This is done with a data structure holding every mode (7) and every property of that mode. Example:

    ionian => [
        { chord => 'maj', roman => 'r_I',   function => 'tonic' },
        { chord => 'min', roman => 'r_ii',  function => 'supertonic' },
        { chord => 'min', roman => 'r_iii', function => 'mediant' },
        { chord => 'maj', roman => 'r_IV',  function => 'subdominant' },
        { chord => 'maj', roman => 'r_V',   function => 'dominant' },
        { chord => 'min', roman => 'r_vi',  function => 'submediant' },
        { chord => 'dim', roman => 'r_vii', function => 'leading_tone' }
    ],
    etc.

Next, I literally append the single rule about pivot chords and what modes/keys and diatonic functions they are in. That rule looks like that:

    pivot_chord_keys(ChordNote, Chord, Key1Note, Key1, Key1Function, Key1Roman, Key2Note, Key2, Key2Function, Key2Roman) :-
        chord_key(ChordNote, Chord, Key1Note, Key1, Key1Function, Key1Roman),
        chord_key(ChordNote, Chord, Key2Note, Key2, Key2Function, Key2Roman),
        Key1Function \= Key2Function.

This associates a chord, the "source" mode (key) that it functions in, and the "destination" mode (key) that we pivot to.

And that's it really! Prolog is "declarative." That is, you don't tell it the steps to take to evaluate things. You just tell it the facts and rules that determine the evaluation of what is true.

So with the [Music::ModalFunction](https://metacpan.org/dist/Music-ModalFunction) module, you can define the database and ask questions of it, in an automated fashion. For instance, consider the example Perl program, "mode-pivot", that comes with the distribution. It generates a chord progression that changes keys, based on the final chord in a section (of four whole note measures). This chord acts as the pivot between the original mode and the new mode. And the new mode is determined by 1) querying the database, 2) getting the results, and 3) selecting one at random:

    ...
    my $m = Music::ModalFunction->new(
        chord_note => lc($modal_pitch),
        chord      => $chord,
        mode_note  => $last_pitch,
        mode       => $last_scale,
    );
    my $query = $m->pivot_chord_keys;
    last unless @$query;
    my $result = $query->[ int rand @$q ];
    ...

Each chord progression (generated by [Music::Chord::Progression](https://metacpan.org/dist/Music-Chord-Progression) and [Music::ModalFunction](https://metacpan.org/dist/Music-ModalFunction)) is scored and saved in a MIDI file that you can play with (for instance) [Timidity++](https://timidity.sourceforge.net/).

Voila!
